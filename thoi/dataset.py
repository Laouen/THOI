from typing import Union
from torch.utils.data import IterableDataset, Dataset
from itertools import combinations
import math
import numpy as np
import torch


def unrank_combination(n, k, idx):
    combination = []
    a = n
    b = k
    x = idx
    for i in range(k):
        c = math.comb(a - 1, b - 1)
        while c <= x:
            x -= c
            a -= 1
            c = math.comb(a - 1, b - 1)
        combination.append(n - a)
        a -= 1
        b -= 1
    return combination

class CovarianceDataset(Dataset):
    def __init__(self,
                 covmats: torch.Tensor,
                 partition_order: int,
                 use_cpu: bool = False):
        
        assert len(covmats.shape) == 3, 'The covariance matrix must be 3D. (n_data, n_variables, n_variables)'
        assert isinstance(covmats, torch.Tensor), 'The covariance matrix must be a torch.Tensor'

        self.covmats = covmats

        # Depending on the resources, maybe its better to create the batches on CPU using RAM memory and/or in parallel
        if use_cpu:
            self.covmats = self.covmats.detach().cpu()

        # Force covariance matrix to be contiguous in CPU to use the CPU memory to create the next batche
        self.covmats = self.covmats.contiguous()
        
        self.n_variables = self.covmats.shape[-1]
        self.partition_order = partition_order
        self.num_combinations = math.comb(self.n_variables, self.partition_order)

    def __len__(self):
        """Returns the number of combinations of features of the specified order."""
        return self.num_combinations

    def __getitem__(self, idx):
        """
        Returns the covariance matrix of the partition at the given index.
        
        Parameters:
            idx (int): The index of the partition. It has the same order as the partitions generated by itertools.combinations.
        
        Returns:
            tuple: A tuple containing:
                - nplets_idxs (torch.Tensor): The indices of the features in the current combination.
                - partition_covmat (torch.Tensor): The submatrix of the covariance matrix corresponding to the current combination, shape (order, order).
        """
        nplets_idxs = torch.tensor(unrank_combination(self.n_variables, self.partition_order, idx), device=self.covmats.device)
        partition_covmat = self.covmats[:, nplets_idxs][:, :, nplets_idxs]
        return nplets_idxs, partition_covmat


class HotEncodedMultiOrderDataset(IterableDataset):
    def __init__(self, covmat: Union[np.ndarray, torch.Tensor], min_order: int, max_order: int):

        self.covmat = torch.tensor(covmat).contiguous()
        self.n_variables = self.covmat.shape[0]
        self.min_order = min_order
        self.max_order = max_order

    def __len__(self):
        """Returns the number of combinations of features for all order."""
        return np.sum([
            math.comb(self.n_variables, order)
            for order in range(self.min_order, self.max_order+1)
        ])

    def __iter__(self):
        """
        Iterate over all combinations of features in the dataset.

        Yields:
            tuple: A tuple containing:
                nplets_idxs_hot_conded (np.ndarray): A hot encoded representation of the elements in the current combination.
                partition_covmat (np.ndarray): The masked matrix where the covariance matrix corresponding to the current combination is maintained and the other rows and columns are set as independent normal (0,1) variables.
        """
        for order in range(self.min_order, self.max_order+1):
            for nplets_idxs in combinations(range(self.n_variables), order):
                nplets_idxs_hot_encoded = torch.zeros(self.n_variables, dtype=torch.int)
                nplets_idxs_hot_encoded[list(nplets_idxs)] = 1
                
                yield nplets_idxs_hot_encoded


class NpletsCovariancesDataset(IterableDataset):
    def __init__(self, covmat: torch.Tensor, nplets: torch.Tensor):

        assert covmat.device == nplets.device, 'covariance and nplets'

        self.covmat = covmat
        self.nplets = nplets

    def __len__(self):
        """Returns the number of combinations of features of the specified order."""
        return len(self.nplets)

    def __iter__(self):
        """
        Iterate over all combinations of features in the dataset.

        Yields:
            tuple: A tuple containing:
                partition_covmat (np.ndarray): The subcovmat of the covariance matrix corresponding to the current combination, shape (order, order).
        """
        for nplets_idxs in self.nplets:
            yield self.covmat[nplets_idxs][:,nplets_idxs]
